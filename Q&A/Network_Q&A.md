# 네트워크
## TCP & UDP
<details>
<summary>TCP와 UDP의 차이점에 대해 설명해주세요.</summary>

<hr>

- TCP는 Receiver와 Sender사이에 연결을 만들고 해당 연결을 기반으로 데이터를 주고받는 **연결 지향형 프로토콜**이며 UDP는 연결 없이 전송하는 **비연결형 프로토콜**이다.
- TCP는 데이터를 순서대로 보내고 순서대로 수신하는 반면에 UDP는 수신의 순서가 중요하지 않다.
- TCP는 연결의 체증을 제어하기 위해 흐름제어(Flow Control)과 혼잡제어(Congestion Control)을 진행한다. 반대로 UDP는 수행하지 않는다.
- 속도 측면에서는 비연결형인 UDP가 더 빨라서 스트리밍과 같이 연속성이 중요한 서비스에 사용된다. 반면에 TCP는 속도가 느린대신 연결을 맺고 통신을 하기에 신뢰성이 중요한 서비스에 이용한다.

![](img/network/tcp_udp.png)

<hr>
</details>


<details>
<summary>DNS와 DHCP는 UDP와 TCP중 어떤 프로토콜을 사용할까요?</summary>

<hr>

- UDP를 사용한다. 그 이유는 Sender, Receiver사이에 연결을 맺으면 보내고 받는 데이터 크기에 비하여 연결에 드는 비용이 더 크기 때문이다. Root DNS 같은 경우 모든 것들과 TCP로 연결을 맺게 된다면 부담이 너무 크기에 연결 없는 UDP방식을 사용한다.

<hr>
</details>


<details>
<summary>UDP, TCP의 세그먼트(Segment)는 전송 과정 중 데이터의 변경이 없었다는 것을 어떻게 알까요?</summary>

<hr>

각각의 세그먼트는 헤더의 Checksum을 통해 데이터의 변경이 발생했는지 체크를 해준다.

- Sender는 세그먼트의 16-bit로 표현한 Content와 Header필드 값을 더한 다음 1의 보수를 만들어 checksum 필드에 추가한다.
- Receiver는 반대로 Content와 Header의 필드값을 16-bit로 변환 후 더한 값을 1의 보수로 변경한 후 checksum의 필드와 같은지 확인한다. 만약 같다면 데이터 전송 과정에서 문제가 발생하지 않은 것이고, 다르다면 해당 세그먼드는 에러가 담긴 세그먼트로 판단한다.

<hr>
</details>


<details>
<summary>TCP 3 way handshake에 대해서 설명해주세요.</summary>

<hr>

3 way handshake는 TCP통신에서 가상회선을 만드는 단계이다. 회선을 만드는 과정에서는 SYN 패킷과 ACK 패킷을 통해 회선을 만든다. 과정은 아래와 같다.

![Untitled](img/network/3-way-handshake.png)

1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다.
2. 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 클라이언트가 다시 ACK으로 응답하기를 기다린다.
3. 클라이언트는 서버에게 연결을 맺었다는 ACK을 보내고 이후로부터는 연결이 이루어지게 된다.

<hr>
</details>


<details>
<summary>TCP 4 way handshake에 대해서 설명해주세요.</summary>

<hr>

4 way handshake는 TCP통신에서 가상 회선을 해제하는 단계이다. 과정은 아래와 같다.

![Untitled](img/network/4-way-handshake.png)

1. 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.
2. 서버는 확인메시지(ACK)를 보내고 남은 데이터를 이어서 전송한다.
3. 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송한다.
4. 클라이언트는 확인했다는 메시지를 보낸다.

<hr>
</details>


<details>
<summary>왜 연결을 끊을 때는 4way handshke를 할까요?</summary>

<hr>

- Client가 데이터 전송을 마쳐서 연결을 끊으려 하더라도 Server는 아직 보낼 데이터가 남아 있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메세지를 보낸다.

<hr>
</details>


<details>
<summary>Time-wait이란 무엇일까요?</summary>

<hr>

4way handshake에서 Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN패킷보다 늦게 도착하는 상황이 발생하면 해당 패킷은 Drop되고 데이터는 유실될 것이다. 이러한 현상에 대비하여 Client는 Server로부터 FIN을 수신하더라도 일정시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 TIME_WAIT 라고 한다.

<hr>
</details>


<details>
<summary>TCP와 UDP 패킷구조에는 어떤 차이가 있을까요?</summary>

<hr>

UDP는 비연결형 통신이라 출발지와 목적지의 Port정보와 UDP 세그먼트의 길이, checksum, data(payload)만을 갖고 있다.

하지만 TCP는 연결형 통신에 데이터간 전송 순서를 보장해야하기에 sequence number, ack number, receive window등 여러 추가 데이터들이 들어간다.

<hr>
</details>

## 흐름제어와 혼잡제어
<details>
<summary>흐름제어와 혼잡 제어에 대해 설명해주세요</summary>

<hr>

흐름제어(Flow Control)는 데이터의 수신자가 송신자가 보내주는 데이터의 양을 **수신자의 버퍼사이즈에 오퍼블로우가 발생하지 않도록 속도를 조절**해주는 방법이다.

전송 속도를 조절하는 방법은 상대방에게 응답을 할 때 TCP header중 하나인 **rwnd**에 **남은 버퍼 사이즈 정보를 추가**해서 보내주고 송신자는 해당 데이터를 보고 in-flight data의 양(전송 속도)을 조절한다.

> receive window를 참고하여 조절한다.
>

혼잡제어(Congestion Control)는 **네트워크 내의 패킷 수가 넘치게 증가하는 혼잡 현상을 방지**하는 방법이다. 즉, 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄이는 작업을 말한다.

송신자는 congestion window를 통해 시간에 따른 네트워크 혼잡도를 판단해 Sending Rate를 변경한다.

> congestion window를 통해 조절한다.
>

Sender TCP window = min(congestion window, receive window)

<hr>
</details>

<details>
<summary>혼잡제어에서 윈도우 사이즈가 상황에 따라 어떻게 변경되는지 설명해주세요</summary>

<hr>

혼잡제어는 기본적으로 Window size를 **AIMD**(Additive Increase, Multiplicative Decrease)방식으로 전송이 성공적으로 진행되면 1씩 증가, 실패하면 절반으로 감소하는 방식으로 진행됩니다. 하지만 초기에는 window size를 1씩 증가시키면 최적점으로 가기까지 너무 오랜 시간이 걸려 Slow Start라고 전송이 성공적으로 진행될 시 2배씩 증가하도록 합니다. 2배씩 증가를 하며 손실이 발생하면 그 때부터 AIMD방식으로 손실이 발생했을 때는 2분의 1, 성공하였을 때는 1씩 증가시킵니다.

<hr>
</details>

<details>
<summary>혼잡제어에서 Timeout이 발생했을 때와 패킷 손실이 발생했을 때, 윈도우 사이즈의 변화는 각각 어떨까요?</summary>

<hr>

Timeout은 네트워크 상에 심각한 혼잡이라고 판단하여 Window size를 0으로 줄인 후, 다시 Slow Start를 통해 exponential하게 증가시킵니다. 반면에 패킷 손실의 경우는 AIMD의 방식대로 Window size를 절반으로 줄입니다.

> Timeout이 발생하여 window size를 0으로 줄인 후 Slow Start를 할 경우, 손실이 발생하기까지 window size를 2배 증가시키는 것이 아니라 Timeout이 발생한 지점의 절반 지점까지만 Exponential하게 2배씩 증가한다. 이를 **Congestion Avoidance**라고 한다.
>

<hr>
</details>

<details>
<summary>흐름제어기법 중 슬라이딩 윈도우 방식에대해 설명해주세요</summary>

<hr>

네트워크 상태가 안 좋으면 패킷 유실 가능성이 커지므로 적절한 송신량을 결정해야 하는데 한 번에 데이터를 받을 수 있는 데이터 크기를 윈도우 사이즈(window size)라고 하며 네트워크 상황에 따라 이 윈도우 사이즈를 조절하는 것을 슬라이딩 윈도우(sliding window)라고 한다.

- 슬라이딩 윈도우 프로토콜은 흐름제어를 위한 프로토콜 중 가장 많이 사용된다.
- Stop-and-wait 방식에서는 ack을 받고 나서 다음 프레임을 전송해야하여 비효율적인데 **슬라이딩 윈도우에서는 송신자가 보낸 프레임에 대한 ack을 받지 않더라도 윈도우 내에 있는 다른 프레임을 전송할 수 있다는 이점이 있다.**
- **슬라이딩 윈도는 데이터가 전송되었는지에 대한 확인 응답(ACK)이 수신될 때마다 윈도우의 범위를 이동시키기에 슬라이딩 윈도우라고 부른다.**

- 수신을 처리하고 프레임 재전송을 하는 방법에 따라 GO-BACK-N 과 Selective Retransmission으로 나뉘게 된다.
    - GO-BACK-N
        - 윈도우 내에서 오류가 발생한 프레임 이후의 패킷은 모두 버리고 재전송하는 방식이다.
        - 1~10까지의 프레임이 있을 때, 6번 프레임에 대한 응답이 오지 않는다면 6~10까지의 프레임을 모두 재전송한다.
    - 선택적 재전송 방식 (Selective Retransmission)
        - GO-BACK-N처럼 모든 패킷을 버리는 것이 아닌, 오류가 발생한 프레임만 선택적으로 재전송하는 방식이다.

### Reference
- [슬라이딩 윈도우 프로토콜 (흐름제어)](https://lordofkangs.tistory.com/58)

<hr>
</details>

## OSI 7계층
<details>

<summary>OSI 7계층에 대해 설명해주세요.</summary>

<hr>

OSI 7 계층은 네트워크 프로토콜이 통신하는 구조를 7개의 계층으로 분리하여 각 계층간 상호 작동하는 방식이다.

계층으로는 물리계층, 데이터링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층으로 나뉘게 된다.

- 과거에는 통신용 규약이 표준화되지 않아 각 벤더에서 별도로 개발했기에 호환되지 않는 시스템이나 애플리케이션이 많았고 통신이 불가능했다. 이를 하나의 규약으로 통합하려는 노력이 현재 OSI 7계층으로 남아있다.

> OSI 7계층은 네트워크 동작을 이해하기에 좋지만 현재 대부분의 프로토콜은 TCP/IP 프로토콜 스택 기반으로 되어있다.

- 복잡한 데이터 전송 과정을 OSI 7계층으로 나누어보면 이해하기 쉽다.
- 계층별로 표준화된 프로토콜 템플릿을 통해 네트워크 프로토콜을 전부 개발하는 대신 계층별로 프로토콜을 개발해 네트워크 구성 요소들을 모듈화 할 수 있다.
- OSI 7계층은 계층의 역할과 목표에 따라 크게 2계층으로 나눌 수 있다.
    - 1~4계층: 데이터 플로 계층(Data Flow Layer) / 하위 계층(Lower Layer)
        - 상대방에게 데이터를 잘 전달하는 역할을 갖고 있다.
    - 5~7계층: 애플리케이션 계층(Application Layer) / 상위 계층(Upper Layer)

### 1계층 - 물리 계층

- 물리적 연결과 관련된 정보를 정의한다.
- 주로 전기 신호를 그대로 잘 전달하는 것이 목적이라 전기 신호가 1계층 장비에 들어오면 전기 신호를 재생성해서 내보낸다.
- 1계층 장비는 주소의 개념이 없어 전기 신호가 들어온 포트를 제외하고는 모든 포트에 같은 전기 신호를 전송한다.
- 주요 장비: 허브(Hub), 리피터(Repeater), 케이블(Cable), 커넥터(Connector), 트랜시버(Transeiver), 탭(TAP)
- 주요 프로토콜: RS-232, RS-449, C.35, S 등의 케이블
- PDU: **Bits**

> PDU → Prodocol Data Unit


### 2계층 - 데이터 링크 계층

- 전기 신호를 모아 우리가 알아볼 수 있는 데이터 형태로 처리한다.
- 주소 정보(**MAC**)를 정의하고 정확한 주소로 통신이 되도록 하는데 초점이 맞춰져 있다.

  > MAC 주소를 의미하는 NIC(Network Interface Card)는 2계층 구성요소이다.

- 1계층과 다르게 주소의 개념이 있어 출발지와 도착지 주소를 확인하고 자신에게 보낸 것이 맞는지에 대해 검사한 후 데이터 처리를 수행한다.
- 전기 신호를 모아 데이터 형태로 처리하여 데이터에 대한 에러를 탐지하거나 고치는 역할을 수행할 수 있다.
    - 이더넷 기반 네트워크의 2계층에서는 에러 탐지 역할만 수행한다.
- 주요 장비: **스위치, 브릿지, 네트워크 카드**
- 주요 프로토콜: IEEE 802.2, FDDI
- PDU: **Frames**

### 3계층 - 네트워크 계층

- 논리적 주소인 IP가 정의된다.
- 3계층 장비인 라우터는 네트워크 주소 정보(IP)를 이용해 IP 주소를 이해할 수 있고 IP주소를 사용해 최적의 경로를 찾아 해당 경로로 패킷을 전송하는 역할을 한다.
- 주요 장비: **라우터, L3 스위치**
- 주요 프로토콜: **ARP, IPv4, IPv6, NAT, IPSec, VRRP, 라우팅 프로토콜**
- PDU: **Packets**

### 4계층 - 트랜스포트 계층

- 1,2,3계층은 신호와 데이터를 올바른 위치로 보내고 실제 신호를 잘 만들어 보는데 집중하였다면 4계층은 실제로 해당 데이터들이 정상적으로 잘 보내지도록 확인하는 역할을 한다.
- 패킷이 유실되거나 순서가 바뀌었을 때 바로잡아주는 역할을 담당한다.
- 주요 장비: **로드 밸런서, 방화벽**
- 주요 프로토콜: **TCP, UDP**, SCTP, DCCP, AH, AEP
- PDU: **Segments**

### 5계층 - 세션 계층

- 양 끝단의 응용 프로세스가 연결을 성립하도록 도와주고 연결이 안정적으로 유지되도록 관리하며 작업 완료 후에는 연결을 끊는 역할을 한다.
- TCP/IP 세션을 만들고 없애는 책임을 진다.
- 에러로 중단된 통신에 대한 에러 복구와 재전송도 수행한다.
- 주요 프로토콜: L2TP, PPTP, NFS, RPC, RTCP, SIP, SSH
- PDU: Datas

### 6계층 - 표현 계층

- 표현 방식이 다른 애플리케이션이나 시스템 간 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환시키는 기능을 수행한다.
- 사용자 시스템의 응용 계층에서 데이터의 형식상 차이를 다루는 부담을 줄여준다.
- 번역기나 변환기 역할을 수행한다.
- MIME 인코딩, 암호화, 압축, 코드 변환과 같은 동작이 이루어진다.
- 주요 프로토콜: **TLS, SSH**, AFP
- PDU: Datas

### 7계층 - 애플리케이션 계층

- 애플리케이션 프로세스를 정의하고 애플리케이션 서비스를 수행한다.
- 네트워크 소프트웨어의 UI부분이나 사용자 입출력 부분을 정의한다.
- 주요 프로토콜: **HTTP, SMTP**, SMP, STUN, TFTP, TELNET, FTP
- PDU: Datas

<hr>
</details>

<details>
<summary>OSI 7계층은 왜 나눴을까요?</summary>

<hr>

- 통신이 일어나는 과정을 단계별로 파악할 수 있다.
- 계층이 독립적으로 분리되어 있어 특정 부분에 문제가 발생하면 다른 단계의 장비 및 소프트웨어를 건드리지 않아도 문제가 발생한 단계만 고치면 된다.

<hr>
</details>

<details>
<summary>TCP/IP 4계층에 대해 설명해보세요.</summary>

<hr>

- 현대 네트워크는 대부분 TCP/IP와 이더넷으로 이루어져있다.
- 실용성에 중점을 두고 개발되었다.
- OSI 7계층과 다르게 4계층으로 구분되어 있다.

![](img/network/tcp_ip_4layer.png)

<hr>
</details>

<details>
<summary>인캡슐레이션과 디캡슐레이션에 대해 설명해주세요.</summary>

<hr>

![Untitled](img/network/encapsulation.png)

**인캡슐레이션(Encapsulation)**

- 상위 계층에서 하위 계층으로 데이터를 보내면 물리 계층에서 전기 신호 형태로 네트워크를 통해 신호를 보내는 과정을 의미한다.
    - 상위 계층에서 내려오며 OSI 7계층을 기준으로 4, 3, 2 계층은 각각 네트워크 전송에 있어 자신이 필요한 정보를 헤더에 붙여서 보낸다.
    - 헤더에 붙이는 정보는 우리가 알아볼 수 있는 문자가 아닌 미리 정의된 비트 단위로 쓴다.

**디캡슐레이션(Decapsulation)**

- 하위 계층에서 상위 계층으로 데이터를 보내는 과정을 의미한다.
    - 상위 계층으로 디캡슐레이션하면서 각각 계층에서 추가된 헤더를 벗겨내며 정보를 확인한다.

📌 헤더에 아래의 정보는 반드시 포함되어 있어야 한다.

- **현재 계층에서 정의하는 정보**
    - 4계층의 목적은 큰 데이터를 잘 분할하고 받는 쪽에서 잘 조립하는 것이다. 시퀀스, 애크 번호와 같이 데이터의 순서와 누락된 패킷이 없는지 확인하는데 필요한 정보를 헤더에 적어 넣는다.
    - 3계층 헤더에는 3계층에서 정의하는 논리적인 주소인 **출발지, 도착지 IP 주소**를 헤더에 적어둔다.
    - 2계층은 MAC 주소를 정의하는데 3계층처럼 2계층도 **출발지, 도착지 MAC 주소** 정보를 헤더에 넣습니다.
- **상위 프로토콜 지시자**

  > 인캡슐레이션 과정에서는 상위 프로토콜이 많아도 문제가 없지만 디캡슐레이션하는 목적지 쪽에서는 헤더에 아무 정보가 없으면 어떤 상위 프로토콜로 올려보내 줘야 할지 결정할 수 없다. 그래서 헤더에 상위 프로토콜 지지자는 필수적으로 기재해야 한다.
  >

  > 각 계층마다 상위 프로토콜 지지자를 갖고 있지만 이름이 달라 4계층은 포트 번호(Port Number), 3계층은 프로토콜 번호(Protocol Number), 2계층은 이더 타입(Ether type)이라고 부른다.
  >
  > - 포트번호는 4계층 헤더에 기재되었지만 애플리케이션 계층에서 프로토콜 종류를 나타내주는 정보이다.

<hr>
</details>


<details>
<summary>TCP/IP란 무엇일까요?</summary>

<hr>

TCP/IP는 **인터넷 프로토콜 스위트**로 온라인상의 안전하고 효율적인 데이터 전송의 필수 요건을 정의한다.

> 인터넷 프로토콜 스위트(Internet Protocol Suite)는 인터넷에서 컴퓨터들이 서로 정보를 주고받는데 쓰이는 통신규약(프로토콜)의 모음이다.
>

> 인터넷 프로토콜 중 TCP와 IP가 가장 많이 쓰이기 때문에 TCP/IP 프로토콜 슈트라고 불린다. (거의 현대 네트워크의 대부분이 TCP/IP와 이더넷으로 이루어져있다.)
>

TCP/IP는 패킷 통신 방식의 인터넷 프로토콜인 IP (인터넷 프로토콜)와 전송 조절 프로토콜인 TCP (전송 제어 프로토콜)로 이루어져 있다. IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있다. TCP는 IP 위에서 동작하는 프로토콜로, 데이터의 전달을 보증하고 보낸 순서대로 받게 해준다. HTTP, FTP, SMTP 등 TCP를 기반으로 한 많은 수의 애플리케이션 프로토콜들이 IP 위에서 동작하기 때문에, 묶어서 TCP/IP로 부르기도 한다.

즉, TCP/IP를 사용한다는 것은 송신자가 수신자에게 IP 주소를 사용하여 데이터를 전달하고 해당 전송의 신뢰성은 TCP를 통해 유지하게 된다.

### OSI와 비교

두 모델은 관련은 있으나 서로 완전히 들어맞지는 않는다.

가장 큰 차이는 계층의 수다. OSI 7계층과 다르게 4계층으로 구분되어 있다.

![Untitled](img/network/tcp-ip.png)

### Reference
- [https://aws-hyoh.tistory.com/entry/TCPIP-쉽게-이해하기](https://aws-hyoh.tistory.com/entry/TCPIP-쉽게-이해하기)

<hr>
</details>

## Http/Https란?
<details>
<summary>HTTP란 무엇일까요?</summary>

<hr>

- 서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜이다.
- 인터넷 상에서 하이퍼텍스트를 교환하기 위해 **통신규약으로 80포트를 사용**하고 있다.
- OSI 7계층 중에서는 **7계층인 애플리케이션 레벨**에 속하며 TCP/IP위에서 작동한다.
- 상태를 갖고 있지 않은 **Stateless 프로토콜**이며 Method, Path, Version, Header, Body 등으로 구조가 구성되어 있다.

<hr>
</details>

<details>
<summary>HTTP 1.0 vs HTTP 1.1 vs HTTP 2.0</summary>

<hr>

### HTTP 1.0

- 브라우저에 친화적인 프로토콜이다.
- Method: GET, HEAD, POST
- Connection 특성: 응답 직후 종료

> Connection을 응답 직후에 닫기 때문에 각각의 요청마다 새로운 연결을 열고 닫으며 불필요한 3-way handshaking을 하게 된다.


### HTTP 1.1

- 오늘날 가장 많이 사용되는 HTTP 버전이다.
- 영구 및 `파이프 라인` 연결, 압축/압축 해제, 가상 호스팅, 캐시 등이 추가되어 응답속도가 빨라지고 대역폭이 절약되는 등 성능 최적화 및 기능 향상되었다.
- Method: GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS
- Connection 특성: Persistent Connection(지속 연결)
    - 한번 Connection을 맺고 해당 Connection이 열려있다면, Connection을 통해 Request/Response 작업을 진행한다.
    - `HTTP 1.1 Keep-Alive Pipelining`: Pipelining을 사용할 때, client는 여러 request를 response의 응답을 기다리지 않고 보낼 수 있다.
    - `HTTP 1.1 Keep-Alive Multiple Connections`: 클라이언트는 많은 양의 objects를 검색하는 성능을 높이기 위해 TCP 다중 연결을 할 수 있다.

### HTTP 2.0

- HTTP 1.1 프로토콜을 계승하며 성능 향상에 초점을 맞췄다.
    - HTTP 1.1은 Plain Text(평문)을 사용하고 개행으로 구별되었으나 2.0은 바이너리 포맷으로 인코딩된 Message, Frame으로 구성된다.
- Connection: **Multiplexed Streams**
    - 한 Connection으로 동시에 여러 개 메시지를 주고 받을 수 있으며, Response는 순서에 상관없이 stream으로 주고받는다.

### Reference
- [HTTP 프로토콜 1.0 vs 1.1 vs 2.0 비교](https://hirlawldo.tistory.com/106)

<hr>
</details>


<details>
<summary>HTTPS를 해야하는 이유에 대해 설명해주세요</summary>

<hr>

패킷 탈취, 클라이언트 위장할 수 있는 등의 보안문제로부터 사용자와 서비스를 보호해줍니다.

<hr>
</details>

<details>
<summary>HTTP와 HTTPS의 차이점에 대해서 설명해주세요</summary>

<hr>

- HTTP는 따로 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로챌 수 있고, 수정할 수 있다. 즉, HTTP는 보안에 취약점이 있어 이를 보안하기 위해 HTTPS가 나왔다. HTTPS는 중간에 암호화 계층을 거쳐서 패킷을 암호화한다.
- HTTP는 통신규약으로 80포트를 사용하며 HTTPS는 443포트를 사용한다.
- HTTPS는 대칭키와 비대칭키 암호화를 모두 사용하여 빠른 연산속도와 안정성을 모두 얻고 있다. HTTP와 비교하였을 때는 키의 암호화/복호화 과정이 필요하여 속도가 느리긴하지만 거의 차이를 느끼기 어렵다.

### HTTPS 동작 과정

1. 브라우저(클라이언트)가 서버로 최초 연결을 시도한다.
2. 서버는 인증서(공개키)를 브라우저에게 넘겨준다.
3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급한다.
4. 브라우저는 세션키를 보관하고 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송한다.
5. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻는다.
6. 브라우저와 서버는 동일한 세션키를 공유함으로 데이터를 전달할 때 세션키로 암호화/복호화를 진행한다.

### Reference
- [2022-ConquerCS/HTTP vs HTTPS.md at main · woowacourse-study/2022-ConquerCS](https://github.com/woowacourse-study/2022-ConquerCS/blob/main/2%EC%A3%BC%EC%B0%A8/%EB%A0%89%EC%8A%A4/HTTP%20vs%20HTTPS.md)

<hr>
</details>


<details>
<summary>stateful와 stateless의 차이점에 대해 설명하세요</summary>

<hr>

### Stateful

**Statsful**은 서버가 클라이언트의 상태를 보존하여 둘 사이의 상태를 유지하는 것을 의미한다. 대표적으로는 홈페이지 로그인을 하였을 때 서버가 상태를 유지하여 페이지를 이동하여도 로그인이 유지되는 예가 있다. 이때 정보들은 일반적으로 브라우저의 쿠키나 서버의 세션 메모리에 저장한다.

- Stateful은 사용중이던 서버의 사용이 어려워져 다른 서버를 사용해야 할 때 발생한다. 다른 서버를 사용할 경우, 해당 서버에서는 이전에 사용하던 서버에서 갖고 있던 상태값들을 갖고있지 않아서 문제가 발생하게 된다.
- 또한 서버에서 갖고 있을 클라이언트의 정보량(용량)은 한정적일텐데 많은 유저가 몰릴 경우 처리량의 한계를 느낄 수 있다.

> 현업에서는 이러한 클라이언트의 상태 데이터를 따로 캐시 서버(Redis)에 저장하여 이용한다.
>

> 프로토콜로는 TCP가 있다.
>

### Stateless

**Stateless**는 서버가 클라이언트의 상태를 보존하지 않는 관계를 의미한다. 서버는 단순히 요청이 오면 응답을 보내주는 역할만을 수행하며, 상태 관리는 모두 클라이언트에게 위임한다. 즉, 통신에 필요한 모든상태 정보는 클라이언트가 갖고있다가 서버와 통신할 때 해당 정보들을 같이 보내어 통신을 하는 구조이다. 덕분에 Stateful와 다르게 사용중이던 서버의 장애가 발생하였을 때 다른 서버를 이용하여도 문제가 없다.

- 대표적인 Stateless 프로토콜로는 UDP와 HTTP가 있다.
- 스케일 아웃(수평확장)이 유리하다.
- 단점
  - Stateless의 문제점으로는 대표적으로 요청을 할 때마다 자신의 정보를 담아 보내야해서 Stateful보다 많은 데이터가 소모된다는 점이있다.
  - 요청마다 TCP/IP 을 새로 맺어야 함 - 3 way handshake 시간이 추가됨.
  - 단적인 예로는 페이지 로딩을 위해 html, js, css 등의 파일을 로드할 때 N번의 3way handshaking이 필요했다.
  - 지금은 http 지속 연결(Persistent Connections)로 문제 해결

### Reference
- [[WEB] 🌐 Stateful / Stateless 차이 💯 정리](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-Stateful-Stateless-%EC%A0%95%EB%A6%AC)

<hr>
</details>


<details>
<summary>SSL(Secure Socket Layer), TLS(Transport Layer Security)가 무엇인가요?</summary>

<hr>

HTTPS를 위해 사용되는 **암호화기반의 인터넷 보안 프로토콜**이다. 이는 전달되는 모든 데이터를 암호화하고 사이버 공격도 차단한다.

둘의 차이 SSL은 1996년 이후 업데이트 되지 않고 사라지고 있다. 그렇기에 취약성도 있어 사용 중단을 권장하고 있다. 이를 대체할 것이 바로 TLS이다. TLS는 SSL의 업데이트 버전이다.

<hr>
</details>


<details>
<summary>SSL/TLS Handshaking에 대해 설명해보세요</summary>

<hr>

![Untitled](img/network/ssl-handshaking.png)

1. ***ClientHello(암호화 알고리즘 나열 및 전달)***: 클라이언트가 서버에 연결을 시도하며 전송하는 패킷이다. 자신이 사용가능한 Cyper Suite 목록, SessionID, SSL 프로토콜 버전, Random Byte등을 전달한다.

   > Cipher Suite는 SSL 프로토콜 버전, 인증서 검정, 데이터 암호화 프로토콜, Hash 방식 등의 정보를 담고 있는 존재이다.

2. ***ServerHello(암호화 알고리즘 선택)***:  서버는 클라이언트가 보낸 ClientHello 패킷을 받아 CyperSuite 중 하나를 선택한 후 자신의 SSL 프로토콜 버전 등과 함께 다음 클라이언트에게 보낸다.

   > ClientHello에서 보낸 Cyper Suite는 여러개이지만 ServerHello에서는 서버가 한개만을 선택하여 보내기에 1개의 CyperSuite가 들어있다.

3. ***Server Certificate(인증서 전달)***: Server는 자신의 Server가 발행한 공개키가 들어있는 SSL인증서를 클라이언트에게 전달한다. 클라이언트는 서버가 보낸 CA의 개인키로 암호화된 SSL인증서를 CA에 등록되어있는 공개키를 사용해 복호화한다. 복호화에 성공하면 인증서는 CA가 서명한 것이 맞으니 유효성 검증이 되는 것이다.
    1. ***Server Key Exchange / ServerHello Done***:  서버의 공개키가 SSL 인증서 내부에 없는 경우 서버가 직접 전달하겠다는 뜻으로 공개키가 SSL 인증서 내부에 있을 경우 Server KeyExchange 과정은 생략된다.

       인증서 내부에 서버의 공개키가 있다면 클라이언트가 CA의 공개키를 통해 인증서를 복호화한 후 서버의 공개키를 확보할 수 있다. 그리고 서버가 작업을 마쳤다고 **ServerHelloDone**을 전달한다.

4. ***Client Key Exchange(데이터를 암호화 할 대칭키 전달)***: 클라이언트는 데이터 암호화에 사용할 대칭키를 생성한 후 SSL 인증서 내부에서 추출한 서버의 공개키를 이용하여 암호화한 후 서버에 전달한다. 전달된 대칭키가 SSL Handshaking의 목적이자, 추후 데이터를 암호화할 대칭키이다.
5. ***Client/Server Hello Done(정보 전달 완료)***
6. ***ChangeCipherSpec/ Finished*** : ChangeCiperSpec 패킷은 클라이언트와 서버 모두가 서로에게 보내는 패킷으로 교환할 정보를 모두 교환한 뒤 통신할 준비가 다 되었음을 알리는 패킷이다. 그 후 finish 패킷을 보내어 SSL handshake를 종료한다.

### Reference
- [2022-ConquerCS/TLS, SSL HandShake.md at main · woowacourse-study/2022-ConquerCS](https://github.com/woowacourse-study/2022-ConquerCS/blob/main/2%EC%A3%BC%EC%B0%A8/%EB%A0%89%EC%8A%A4/TLS%2C%20SSL%20HandShake.md)

<hr>
</details>


<details>
<summary>HTTP 메서드와 이것이 하는 역할에 대해서 설명해보세요.</summary>

<hr>

HTTP 메소드는 `클라이언트가 웹 서버에게 사용자 요청의 목적이나 종류를 알리는 수단`이다.

- `GET` : 리소스 조회
- `POST` : 요청 데이터 처리, 주로 데이터 등록에 사용
- `PUT` : 리소스를 대체, 해당 리소스가 없으면 생성
- `PATCH` : 리소스를 일부만 변경
- `DELETE` : 리소스 삭제
- `HEAD`: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
- `OPTIONS`: 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
- `CONNECT`: 대상 자원으로 식별되는 서버에 대한 터널을 설정
- `TRACE`: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

![](img/network/http_method.png)

<hr>
</details>


<details>
<summary>HTTP 상태코드란 무엇이며 어떤 것들이 존재하는지 설명해보시오.</summary>

<hr>

http 상태 코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능이다.

- **1xx (Informational)**: 요청이 수신되어 처리중
- **2xx (Successful)**: 요청 정상 처리
- **3xx (Redirection)**: 요청을 완료하려면 추가 행동이 필요
- **4xx (Client Error)**: 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
- **5xx (Server Error)**: 서버 오류, 서버가 정상 요청을 처리하지 못함

<hr>
</details>

<details>
<summary>GET과 POST의 차이점에 대해서 설명해보세요.</summary>

<hr>

- GET: 서버로부터 리소스를 가져오기 위해 사용된다.
- POST: 서버로부터 리소스를 생성/변경하기 위해 사용된다.

**차이**

- GET의 경우 요청에 대해 캐시가 가능하고 POST는 캐시가 불가능하다.
- GET 요청은 멱등하나 POST는 서버에 리소스를 생성/업데이트 하여 멱등하다고 볼 수 없다.

<hr>
</details>


<details>
<summary>PUT과 PATCH의 차이에 대해 설명해주세요.</summary>

<hr>

- `PUT` : 리소스의 **모든 것**을 업데이트 한다.
- `PATCH` : 리소스의 **일부**를 업데이트 한다.

`PUT`은 항상 전체 리소스를 포함하여 요청을 보내어 **멱등성**(같은 요청을 여러번 수행하여도 동일한 결과를 만드는)성질을 갖고 있다.

하지만 반대로 `PATCH`는 변경을 하고싶은 일부 속성만을 변경하기에 상황에 따라 멱등성을 보장할 수도, 보장되지 않을 수도 있다.

대표적인 예시를 들면 `PATCH`요청을 보낼 때, 나이를 30으로 업데이트 하는 요청을 body에 `age:30`과 같이 명시적으로 보낼 경우 멱등성을 보장한다. 하지만 나이를 한 살 올리라는 의미로 `value:1` 의 값을 body에 담아 보낼 경우 요청을 보낼 때마다 결과가 달라 멱등하지 않게 된다.

### Reference
- [[ RESTful API] PUT과 PATCH의 차이 - 멱동성을 보장하는 PUT, 멱등성을 보장하지 않는 PATCH](https://oen-blog.tistory.com/211)

<hr>
</details>


<details>
<summary>HTTP keep-alive / TCP keep-alive</summary>

<hr>

**HTTP keep-alive**

`HTTP keep-alive`는 HTTP의 Persistent Connection을 맺는 기법 중 하나로 `HTTP 1.0+`부터 지원하고 있다. 하지만 해당 옵션은 설계상 여러 문제점(e.g. proxy 문제)이 생기며 `HTTP/1.1`부터는 사용되고 있지 않지만 여전히 많은 웹 애플리케이션에서 사용하고 있다.

> `HTTP/1.1`은 기본적으로 Persistent Connection을 지원하지만 `HTTP/1.0`은 하나의 요청이 끝나면 Connection을 닫는 것이 기본 설정이라 HTTP/1.0에서 지속 커넥션을 사용하려면 특정한 헤더들을 추가해줘야 한다. 그것이 바로 Connection 헤더와 Keep-alive 헤더이다.
>

**TCP의 Keep alive**

3-way handshake를 통해 얻은 세션을 요청에 대한 응답을 하더라도 없애지 않고 계속 유지해주는 기능이다.

![Untitled](img/network/tcp_keepAlive.png)

그림과 같이 TCP Keepalive는 일정 시간이 지나면 연결된 세션이 살아있는지 확인하기 위해 아주 작은 양의 패킷을 하나 보낸다. 패킷은 연결을 유지하기 원하는 쪽에서 보낸다. 패킷을 주고 받은 다음에 타이머는 원점으로 돌아가고 카운트를 진행한다.
최초로 세션이 연결된 다음 `tcp_keepalive_time` 동안 기다린다. 그리고 확인 패킷을 보내게 된다. 확인 패킷에 대한 응답이 오지 않으면 `tcp_keepalive_intv` 간격으로 `tcp_keepalive_probes` 만큼 패킷을 더 보낸다. `tcp_keepalive_probes`의 마지막 패킷에 대해서 응답이 오지 않으면 연결을 끊는다.
TCP Keepalive는 연결된 세션의 재활용 측면에서만 아니라 좀비 커넥션의 삭제에도 도움을 준다.
TCP 연결을 끊으려면 FIN 패킷이 필요하다. 하지만 다양한 이유로 FIN 패킷을 받을 수 없는 상황이 된다면 FIN 을 전달할 수 없어 계속 연결된 것처럼 남아있게 된다. TCP Keepalive 옵션을 사용한다면 일정시간동안 확인 패킷을 보내는 로직을 통해 일정시간 동안 응답이 없다면 연결을 종료하기 때문에 좀비 커넥션을 방지할 수 있다.

> TCP Keep-alive는 두 종단 간의 연결을 유지하기 위함이지만, HTTP keep-alive는 최대 얼마동안 연결을 유지할지 정하는 목적을 갖고 있다.
>

### Reference
- [Keepalive 정리](https://devidea.tistory.com/60)

<hr>
</details>


<details>
<summary>REST, RESTful이란 무엇일까요?</summary>

<hr>

Representational State Transfer(REST)는 API 작동 방식에 대한 조건을 부과하는 소프트웨어 아키텍처이다. REST 아키텍처 스타일을 따르는 API를 REST API라고 한다. 또한 REST 아키텍처를 구현하는 웹 서비스를 RESTful 웹 서비스라고 한다.

> RESTful API라는 용어는 일반적으로 RESTful 웹 API를 나타낸다.
>

REST의 특징은 Uri로 자원을 표시하고, 행위를 Http Method로 표현한다는 특징이 있다.

### REST 아키텍처 스타일의 원칙

- Uniform Interface (균일한 인터페이스)
  - 균일한 인터페이스는 모든 RESTful 웹 서비스 디자인의 기본으로 서버가 표준 형식으로 정보를 전송함을 나타냅니다.
- Stateless (무상태)
  - 클라이언트는 임의의 순서로 리소스를 요청할 수 있으며 모든 요청은 무상태이거나 다른 요청과 분리된다.
- Cacheable (캐시 가능성)
  - RESTful 웹 서비스는 서버 응답 시간을 개선하기 위해 클라이언트 또는 중개자에 일부 응답을 저장하는 프로세스인 캐싱을 지원한다.
- 온디맨드 코드
  - REST 아키텍처 스타일에서 서버는 소프트웨어 프로그래밍 코드를 클라이언트에 전송하여 클라이언트 기능을 일시적으로 확장하거나 사용자 지정할 수 있다.
- 계층화 시스템

### RESTful API의 이점

- **확장성**

  REST API를 구현하는 시스템은 REST가 클라이언트-서버 상호 작용을 최적화하기 때문에 효율적으로 크기 조정할 수 있습니다. 무상태는 서버가 과거 클라이언트 요청 정보를 유지할 필요가 없기 때문에 서버 로드를 제거합니다. 잘 관리된 캐싱은 일부 클라이언트-서버 상호 작용을 부분적으로 또는 완전히 제거합니다. 이러한 모든 기능은 성능을 저하시키는 통신 병목 현상을 일으키지 않으면서 확장성을 지원합니다.

- **유연성**

  RESTful 웹 서비스는 완전한 클라이언트-서버 분리를 지원합니다. 각 부분이 독립적으로 발전할 수 있도록 다양한 서버 구성 요소를 단순화하고 분리합니다. 서버 애플리케이션의 플랫폼 또는 기술 변경은 클라이언트 애플리케이션에 영향을 주지 않습니다. 애플리케이션 함수를 계층화하는 기능은 유연성을 더욱 향상시킵니다. 예를 들어, 개발자는 애플리케이션 로직을 다시 작성하지 않고도 데이터베이스 계층을 변경할 수 있습니다.

- **독립성**

  REST API는 사용되는 기술과 독립적입니다. API 설계에 영향을 주지 않고 다양한 프로그래밍 언어로 클라이언트 및 서버 애플리케이션을 모두 작성할 수 있습니다. 또한 통신에 영향을 주지 않고 양쪽의 기본 기술을 변경할 수 있습니다.

<hr>
</details>


<details>
<summary>URL과 URI는 뭐가 다를까?</summary>

<hr>

URL은 `위치 지정자`, URI는 `식별자`이다.

- URL은 Domain name

<hr>
</details>

## 웹 통신 흐름

<details>
<summary>https://www.google.com/ 을 접속할 때 일어나는 일에 대해 설명해주세요</summary>

<hr>

1. 웹 브라우저에 URL을 입력하고 Enter 키를 누릅니다.
2. 웹 브라우저가 도메인의 IP 주소를 조회합니다. (먼저 캐시를 찾고, 그다음 DNS를 검색합니다.)
  - Local DNS, Root DNS, TLD(Top Level Domain), Authoritative DNS 서버 순으로 탐색
3. 웹 브라우저가 찾은 IP 주소를 기반으로 서버와의 TCP 연결을 시작합니다.

   TCP/IP(Transmission Control Protocol/Internet Protocol)라고 하는 전송 제어 프로토콜을 사용하여 라우터 장비, 인터넷 서비스 제공회사 교환기를 통해 이동되어, 통신 회사간 경로인 라우팅 테이블을 따라서 연결할 IP 주소가 있는 웹 서버를 찾는다.

   > 요즘에는 많은 웹 사이트들이 직접 서버에 연결하기 보다는 콘텐츠 전송 네트워크(CDN)를 사용하여 정적 및 동적 콘텐츠를 웹 브라우저 가까이에 위치 시킨다.
   >

   > CDN은 콘텐츠를 사용자에게 더 가까이 제공하여 사이트의 원본 연결 성능을 개선하는 캐싱 서버의 글로벌 분산 네트워크입니다.
   >

   웹 브라우저가 인터넷에서 서버를 찾으면 웹 서버와 TCP 연결을 설정하고, HTTP를 통해 평문 통신을 시작합니다. 그러나, HTTPS를 사용하는 경우 주고 받는 데이터의 암호화를 위한 TLS (Transport Layer Security) 핸드셰이크라는 추가 과정을 수행한다.

4. 웹 브라우저가 HTTP 요청을 서버로 전송합니다. (필요한 경우, HTTPS 보안 통신이 진행됩니다.)

   웹 브라우저가 서버에 연결되면 통신 규약에 따라 요청을 보낸다.

5. 웹 서버가 요청을 처리하고 응답을 다시 웹 브라우저로 전송합니다.
  - 해당 부분에서는 Spring MVC 동작 과정을 엮어서 설명해도 좋다.
6. 웹 브라우저가 전송 받은 콘텐츠를 렌더링합니다.

<hr>
</details>


<details>
<summary>MAC 주소에 대해 설명해주세요.</summary>

<hr>

MAC(Media Access Control) 주소는 컴퓨터간 데이터를 전송하기 위해 있는 컴퓨터의 물리적 주소이다. 네트워크에 접속하는 모든 장비는 MAC주소라는 **물리적인 주소**가 있어야 해당 주소를 통해 통신할 수 있다. 통신은 일반적으로 논리적 주소인 IP를 기반으로 데이터를 요청/응답을 받는데 IP간 통신을 할 때는 내부적으로 2계층에서 각 라우터의 hop에서 MAC 주소와 MAC 주소 통신의 연속적인 과정을 거치게 된다.

- NIC(Network Interface Card)를 가진 각각의 기기들(컴퓨터, 라우터, 스위치 등)은 제조사가 부여하는 고유 번호인 MAC 주소를 갖고 있다.
- **MAC 주소는 2계층인 데이터 링크 계층**에서 사용된다.
- MAC 주소는 네트워크 장비 제조업체에서 장비를 출하할 때, 제조 업체에 할당된 주소 풀에 있는 주소를 할당한다
    - 제조 업체에 할당된 주소 풀을 **제조사 코드(Vendor Code)**라고 부르며 이는 국제 기구인 IEEE가 관리한다.
    - 생산할 때 하드웨어적으로 정해져 나오므로 **BIA(Burned-In Address)**라고도 부른다.
- MAC 주소는 16진수 12자리의 **48비트**로 표현된다.
    - 48비트는 24비트 단위로 앞 뒤로 구분된다.
    - 앞의 24비트인 **OUI**는 **제조사 코드**가 들어간다.
    - 뒤의 24비트인 **UAA**는 각 제조사에서 자체적으로 할당한다.
- 2계층에서의 동작
    - NIC는 자신의 MAC 주소를 갖고있고 전기 신호가 들어오면 2계층에서 데이터 형태(패킷)으로 변환하여 내용을 구분한 후 도착지 MAC 주소를 확인한다. 이때 도착지 MAC 주소가 자신의 MAC 주소와 다르면 패킷을 폐기한다. 반대로 패킷의 목적지 주소가 자신이거나 브로드캐스트, 멀티캐스트와 같은 그룹 주소이면 처리해야 할 주소로 인지해 패킷 정보를 상위 계층으로 넘겨준다.

PC간 통신을 할 때는 IP주소만을 알고 통신을 하며 거쳐가는 기기들의 MAC주소는 알지 못한다. 우리가 MAC주소를 전달하지 않아도 네트워크단에서 IP주소로 MAC주소를 알아오는 프로토콜이 존재하는데 이를 `ARP`라고 한다.

### Reference
- [맥 어드레스란 무엇인가? IP주소와 맥주소(MAC address) 차이, 맥 주소 확인하는 법 - 네트워크 기초](https://jhnyang.tistory.com/404)

<hr>
</details>


<details>
<summary>MAC 주소가 존재하는데 왜 MAC주소로 통신을 안하고 IP주소로 통신할까요?</summary>

<hr>

MAC 주소는 바로 옆 기기와의 통신에만 사용된다. 거리가 멀리 있는 기기간의 통신을 하게 될 경우 중간에 여러 기기들을 거쳐가야하기에 MAC주소로는 판단할 수 있다.

이를 해결하기 위해 IP주소가 존재한다. 만약 IP 주소 없이 MAC 주소만을 통해 라우팅한다면 각 고유한 주소를 라우팅 테이블에 일일이 입력하면 라우터에 부하가 걸릴 것이다. IP주소는 연속성을 갖기 때문에 IP주소를 다수로 한줄에 지정해줄 수 있으니 편리하다는 이점이 있다.

반대로 IP주소만을 사용할 경우에는 IP주소는 논리적인 주소라 언제든지 변경될 수 있는 특성때문에 문제가 발생할 수 있다. 그리하여 변경되지 않는 물리적 MAC 주소를 같이 사용한다.

<hr>
</details>

<details>
<summary>IP 주소에 대해 설명해주세요 (+ 서브넷 마스크까지)</summary>

<hr>

- IP는 v4, v6 두 체계가 사용되며 IPv4는 32비트, IPv6는 128비트이다.
- IPv4를 표기할 때는 4개의 옥텟(Octet, `.`)이라고 불리는 단위로 나눈다.
- MAC 주소는 16진수로 표현하였지만 IP는 10진수로 표기한다.
- IP 주소는 **네트워크 주소**와 **호스트 주소** 두 부분으로 나뉜다.→ 서브넷 마스크
    - **네트워크 주소** - 호스트들을 모은 네트워크를 지칭하는 주소로 네트워크 주소가 동일한 네트워크를 로컬 네트워크라고 한다.
    - **호스트 주소** - 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소이다.
    - 둘의 구분은 MAC 주소와 다르게 구분하는 경계점이 고정되어 있지 않다.
    - IP주소가 경계점을 고정하지 않은 이유는 **고정 네트워크 주소 체계에 비해 주소를 절약할 수 있다는 장점이 있기 때문**이다. → IP가 많이 필요한 곳이 있고 적게 필요한 곳들이 있어 가변적으로 만들 수 있다.

  > IP주소 체계는 필요한 호스트 IP 개수에 따라 네트워크의 크기를 다르게 할당할 수 있는 클래스(class)개념을 도입했다. A클래스는 1,600만개, B 클래스는 약 6만 5천개, C 클래스는 약 250개의 IP주소를 가질 수 있다. 각각 클래스를 구분하는 것은 네트워크 주소와 호스트 주소의 구분점이 어느 옥텟에 있는지에 따라 나뉘게 되며 이 구분자를 **서브넷 마스크**라고 한다.
  >

  > 클래스 기반의 네트워크 분할 기법은 과거에 사용했던 개념이고 현재는 클래스 기반으로 네트워크를 분할하지 않고 세밀하게 분할하고 할당하기 위해 네트워크 크기에 맞추어 1비트 단위로 네트워크를 상세히 분할한다.
>
- IP 체계에서는 맨 앞의 숫자를 네트워크 주소로, 맨 뒤의 숫자를 브로드캐스트 주소로 사용한다.

### 클래스풀과 클래스리스

앞서 A,B,C 클래스와 같은 클래스 기반의 IP 주소 체계를 클래스풀(classful)이라고 부른다. 초기 IP 주소 체계를 만들 때는 클래스 개념을 도입하여 확장성과 주소 낭비가 적은 최적의 조건을 만들 수 있었다. 하지만 클래스풀 기반의 체계는 낭비되는 IP들이 존재하여 늘어나는 IP 주소를 감당하기에 부족하였다. 이러한 IP 낭비 문제를 해결하기 위해 아래의 3가지 보존, 전환 전략을 만들어냈다.

- 클래스리스, CIDR(Classless Inter-Domain Routing) 기반의 주소 체계
- NAT와 사설 IP 주소
- IPv6

클래스리스 주소체계는 클래스 개념을 적용하지 않은 주소 체계이다. 클래스풀에서는 옥텟을 기준으로 클래스를 구분하였다면 클래스리스는 네트워크와 호스트 주소를 나누기 위해 서브넷 마스크(Subnet Mask)라는 구분자를 사용한다.

> 서브넷 마스크
>
> - 서브넷 마스크는 호스트주소와 네트워크 주소를 구분할 때 사용한다.
> - 2진수 숫자 1은 네트워크 주소, 0은 호스트 주소로 표시한다.
> - 보통은 우리가 편하게 읽기 위해 10진수를 사용해 `255.255.0.0`, `255.255.192.0` 과 같이 표현한다.
> - 비트 단위로 표현한다면 네트워크 주소인 1을 연속적으로 표현하여 `255.255.0.0`의 경우 `/16`으로 `255.255.192.0` 의 경우 `/18`로 표현한다.
> - ex) `102.123.53.231` 주소에 `255.255.0.0` 서브넷 마스크를 사용하는 IP는 네트워크 주소가 `102.123.0.0`이고 호스트 주소가 `0.0.53.231`이 된다. → 주소와 서브넷 마스크를 같이 표현할 경우 `102.123.54.231/16` 으로 표현한다.

<hr>
</details>

<details>
<summary>허브, 스위치, 라우터에 대해 설명해주세요</summary>

<hr>

### 허브 (Hub)

- 거리가 멀어질수록 줄어드는 전기 신호를 재생성해주고 여러대의 장비를 연결할 목적으로 사용된다.
- 1계층에서 동작하는 장비이다.
- 단순히 들어온 신호를 모든 포트로 내보내 네트워크에 접속된 모든 단말이 경쟁하게 되어 전체 네트워크의 성능이 줄어드는 문제가 있고 패킷이 무한 순환해 네트워크 전체를 마비시키는 장애의 원인이 되어 **현재 허브는 거의 사용되고 있지 않다.**

### 스위치 (Switch)

- 허브와 동일하게 여러 장비를 연결하고 통신을 중재하는 장비이다.
    - 내부 동작은 다르나 같은 역할을 하여 허브라는 용어를 공통적으로 사용한다.
- 2계층에서 동작하는 장비이다.
- 허브와 다르게 **MAC 주소를 이해하고 목적지가 연결된 포트로만 전기 신호를 보낸다.**

  > 허브는 모든 포트로 전기 신호를 보내고 스위치는 목적지 MAC 주소를 인지해 목적지로만 전기 신호를 보낸다.
>
- 스위치는 효율이 낮고 네트워크 응답 성능을 보장할 수 없었던 이더넷 네트워크가 성능 보장이 가능한 효율 높은 네트워크 기술로 발전할 수 있게 해줬다.

### 라우터 (Router)

- **정확한 방향으로 패킷이 전송되도록 경로를 지정하고 최적의 경로로 패킷을 포워딩한다.**
- 원격지로 쓸데없는 패킷이 전송되지 않도록 브로드캐스트와 멀티캐스트를 컨트롤하고 불분명한 주소로 통신을 시도할 경우, 이를 버린다.
- 3계층에서 동작하는 장비이다.
- 먼 지역에 위치한 네트워크와 통신하기 위해 만들어졌다.

<hr>
</details>

<details>
<summary>스위치는 어떻게 브로드캐스트가 아닌 목적지인 MAC주소로만 유니캐스트로 데이터를 전송할 수 있을까요? 또한 데이터 전송 외에 스위치가 갖는 기능은 무엇이 있을까요? (Switch 내용 심화)</summary>

<hr>

스위치가 없던 과거 이더넷 네트워크에서는 패킷(프레임)을 전송할 때 서로 경합하여 그로 인해 네트워크의 성능 저하가 컸다. 스위치는 이런 경쟁을 없애고 패킷을 동시에 여러 장비가 서로 간섭 없이 통신하도록 도와준다.

- 스위치는 네트워크 중간에서 패킷을 받아 필요한 곳에만 보내주는 네트워크의 중재자 역할을 한다.
    - 스위치의 핵심 역할은 누가 어느 위치에 있는지 파악하고 통신이 시작되면 알고 있는 위치로 패킷을 정확히 전송하는 것이다. → 이러한 동작은 MAC 주소와 단말이 위치하는 인터페이스 정보(포트)를 매핑한 **MAC 주소 테이블**을 갖고 있어서 가능하다.
- 스위치는 아무런 설정 없이 네트워크에 연결해도 2계층 주소인 MAC 주소를 기반으로 패킷을 전달하는 기본 동작을 수행한다.
- 스위치는 MAC 주소를 인식하고 패킷을 전달하는 기능 외에도 아래의 기능들이 존재한다.
    - 한 대의 장비에서 논리적으로 네트워크를 분리할 수 있는 VLAN 기능
    - 네트워크 루프를 방지하는 스패닝 트리 프로토콜(STP)
    - 그 외에도 다양한 보안 기능과 모니터링에 필요한 여러 기능들이 존재한다.
- 스위치의 동작은 MAC 주소 테이블을 기반으로 하며 패킷의 도착지가 테이블에 있으면 해당 주소가 매핑된 포트로만 패킷을 전송하고, 도착지가 테이블에 없다면 스위치는 전체 포트로 패킷을 전달한다. 스위치의 이러한 동작 방식을 아래의 3가지로 정리할 수 있다.
    - **플러딩 (Flooding)**
        - 테이블에 없는 MAC주소에 요청이 왔을 때 전체 포트로 패킷을 전달하는 것을 플러딩(Flooding)이라고 한다.
        - 스위치는 LAN에서 동작하여 자신의 테이블에 정보가 없더라도 어딘가에 장비가 있을 수 있다고 가정하고 도착지가 테이블에 없다면 전체 포트로 패킷을 전달한다.
    - **어드레스 러닝 (Address Learning)**
        - 스위치는 MAC 주소를 확인하고 원하는 포트로 포워딩하기위해 MAC 주소 테이블을 만들고 유지한다. 이러한 MAC 주소 테이블을 만들고 유지하는 과정을 어드레스 러닝이라고 한다.
    - **포워딩/필터링 (Forwarding/Filtering)**
        - MAC 주소 테이블에서 매칭되는 포트로 패킷을 **포워딩**하고 다른 포트로는 해당 패킷을 **필터링**하여 보내지 않는다.
        - 스위치는 일반적인 유니캐스트에 대해서만 포워딩과 필터링 작업을 수행한다.

<hr>
</details>

<details>
<summary>라우터의 동작 방식과 역할에 대해 설명해주세요 (Router 내용 심화)</summary>

<hr>

라우터는 라우터는 **원격지 네트워크(다른 LAN)와 연결할 때 필수 네트워크 장비이며 네트워크를 구성하는 핵심 장비**로써 ****정확한 방향으로 패킷이 전송되도록 경로를 지정하고 최적의 경로로 패킷을 포워딩하는 역할을 한다. 위의 문장을 통해 라우터의 역할은 크게 2가지인 것을 알 수 있다.

- **경로 지정**: 다양한 경로 정보를 수집해 최적의 경로를 라우팅 테이블에 저장한 후 패킷이 라우터로 들어오면 도착지 IP 주소와 라우팅 테이블을 비교해 최선의 경로로 패킷을 내보낸다.
- **포워딩**: 라우터에 들어오는 패킷의 목적지 IP 주소를 확인하고 자신이 가진 경로 정보를 이용해 패킷을 최적의 경로로 포워딩해준다.
    - 스위치와 다르게 들어온 패킷의 목적지 주소가 라우팅 테이블에 없으면 패킷을 버린다.
    - 현대 네트워크는 이더넷으로 수렴되며 역할이 줄었지만, 과거에는 LAN에서 사용하는 프로토콜과 WAN에서 사용하는 프로토콜이 전혀 달랐다. 서로 통신을 하려면 서로 기술의 전환이 필요했는데 이러한 역할을 라우터가 담당했다.
    - 포워딩 과정에서는 연결된 네트워크가 서로 다른 프로토콜로 구성되어있다면 이를 변환해준다.
        - **라우터에 패킷이 들어오면 2계층까지의 헤더 정보를 벗겨내고 3계층 주소를 확인한 후 2계층 헤더 정보를 새로 만들어 외부로 내보낸다. 이러한 동작을 하며 헤더 값을 변경하며 프로토콜을 변환하게 된다.** → 라우터에서 들어올 때와 나갈 때의 2계층 헤더 정보가 다른 이유!!!

> 스위치는 대표적인 2계층 장비이지만 라우터처럼 3계층에서 동작하는 L3 스위치도 존재한다. 기존에는 라우터는 소프트웨어로 스위치는 하드웨어로 구현하는 형태로 구분하였으나 최근에는 기술 발달로 라우터와 L3스위치를 구분하기는 어렵다.
>

## 라우팅 동작과 라우팅 테이블

라우터는 현대 인터넷에서는 단말부터 목적지까지 모든 경로를 책임지는 것이 아니라 인접한 라우터(넥스트 홉, Next Hop)까지만 경로를 지정하면 인접 라우터에서 최적의 경로를 다시 파악한 후 다음 라우터로 패킷을 포워딩하는 방식으로 동작한다. 이와 같이 네트워크를 한 단계씩 뛰어넘는다는 의미로 홉-바이-홉(Hop-by-Hop)라우팅이라 부른다.

넥스트 홉을 지정할 때는 일반적으로 세 가지 방법을 사용할 수 있다.

- 다음 라우터의 IP를 지정하는 방법 (넥스트 홉 IP 주소)
- 라우터의 나가는 인터페이스를 지정하는 방법
- 라우터의 나가는 인터페이스와 다음 라우터의 IP를 동시에 지정하는 방법

> 라우팅 테이블에 저장하는 데이터
>
> - 목적지 주소
> - 넥스트 홉 IP 주소, 나가는 로컬 인터페이스 (선택 가능)

## 라우팅 (라우터가 경로 정보를 얻는 방법)

라우터가 경로 정보를 얻는 방법은 크게 3가지로 구분할 수 있다.

- 다이렉트 커넥티드(Direct Connected)
    - IP 주소를 입력하며 자연스럽게 인접 네트워크 정보를 얻는 방법
    - 내가 갖고 있는 네트워크
    - IP주소를 입력할 때 사용된 IP주소와 서브넷 마스크로 해당 IP가 속한 네트워크 주소 정보를 알 수 있다. 이 정보로 해당 네트워크에 대한 라우팅 테이블을 자동으로 만드는데, 해당 경로 정보를 다이렉트 커넥티드라고 부른다. 다이렉트 커넥티드로 생성되는 경로 정보는 인터페이스에 IP를 설정하면 자동 생성되는 정보라 강제로 지울 수 없으며 해당 네트워크 설정을 삭제하던가 네트워크 인터페이스가 비활성화되어야만 자동으로 사라진다.
- 스태틱 라우팅(Static Routing)
    - 관리자가 직접 경로 정보를 입력하는 방법
    - 내가 경로를 직접 지정한 네트워크
    - **관리자가 목적지 네트워크와 넥스트 홉을 라우터에 직접 지정**해 경로 정보를 입력하는 것을 스태틱 라우팅이라고 한다. 스태틱 라우팅은 관리자가 변화가 적은 네트워크에서 네트워크를 손쉽게 관리할 수 있는 좋은 방법이지만 큰 네트워크에서는 관리가 어렵다. → 라우팅 너머 다른 라우터의 상태 정보를 파악할 수 없어 라우터 사이의 회선이나 라우터에 장애가 발생하면 장애 상황을 파악하고 대체 경로로 패킷을 보낼 수 없기 때문이다.
- 다이나믹 라우팅(Dynamic Routing)
    - 라우터끼리 서로 경로 정보를 자동으로 교환하는 방법
    - 경로를 전달받은 네트워크
    - 다이나믹 라우팅은 스태틱 라우팅의 단점을 보완해준다. **라우터끼리 자신이 알고 있는 경로 정보나 링크 상태 정보를 교환해 전체 네트워크 정보를 학습**한다. 주기적으로 또는 상태 정보가 변경될 때 라우터끼리 경로 정보가 교환되므로 라우터를 연결하는 회선이나 라우터 자체에 장애가 발생하면 상황을 인지해 대체 경로로 패킷을 포워딩할 수 있다. 관리자의 개입 없이 라우터끼리 정보교환을 하며 장애를 인지하고 트래픽 우회가 가능하여 **대부분의 네트워크에서는 다이나믹 라우팅이 사용된다.**

### 스위칭 (라우터가 경로를 지정하는 방법 = 포워딩)

패킷이 들어와 라우팅 테이블을 참조하고 최적의 경로를 찾아 라우터 외부로 포워딩하는 작업을 스위칭이라고 합니다.

> 2계층 스위치와 이름은 비슷하나 다른 용어이며 3계층 장비인 라우터가 패킷 경로를 지정해 보내는 작업을 말한다.
>

라우터에 요청이 들어왔을 때, 라우팅 테이블에 완전히 매칭되는 정보가 없다면 도착지 IP와 가장 가깝게 매칭되는 경로를 찾기 위해 **롱기스트 프리픽스 매치(Longest Prefix Match)기법**을 이용해 갖고 있는 경로 정보 중 가장 가까운 경로를 선택한다.

> **롱기스트 프리픽스 매치(Longest Prefix Match)**
>
> - 라우터가 패킷을 포워딩할 때 자신이 갖고 있는 라우팅 테이블에서 가장 좋은 항목을 찾는 알고리즘을 의미한다.

라우터는 한 번 스위칭 작업을 수행한 정보는 캐시에 저장하고 뒤에 들어오는 패킷은 라우팅 테이블에서 확인하기 전에 캐시를 먼저 확인한다. → 패킷 네트워크에서 데이터를 보내기 위해 동일한 출발지 IP, 목적지 IP, 포트 번호로 여러 개의 패킷을 연속으로 보내기 때문에 이러한 기술이 유용하다.

<hr>
</details>

<details>
<summary>ARP에 대해 설명해주세요</summary>

<hr>

2계층에서는 MAC 주소를 기반으로 3계층에서는 IP 주소를 기반으로 목적지를 찾는다. 이때 두 주소는 서로 무관하여 이를 연계해주기 위한 매커니즘이 필요하다. 이 작업을 수행하는 프로토콜이 바로 ARP(Address Resolution Protocol)이다.

ARP(Address Resolution Protocol)는 IP 주소를 MAC주소와 매칭 시키기 위한 프로토콜이다. 로컬 네트워크인 **LAN**에서 단말 간 통신을 하기 위해서는 IP주소와 MAC주소가 함께 이용되는데 IP주소를 MAC 주소와 매칭하여 목적지 IP 단말의 MAC 주소까지 제대로 찾아가기 위해 사용한다.

매핑시키는 과정에서는 IP주소와 MAC주소를 일대일 매칭시킨 정보를 정리해둔 ARP Table을 이용한다. 하지만 논리 주소는 언제든지 바뀔 수 있으므로 일정시간동안 통신이 없으면 해당 테이블은 삭제시킨다.

#### ARP 테이블을 만드는 과정

![Untitled](img/network/arp.png)

PC0이 PC2로 데이터를 전송하려한다면 아래와 같은 순서로 동작한다.

1. PC0은 Routing Table을 보고 PC2가 같은 LAN에 속한다는 것을 알아 PC2의 MAC 주소를 알아내기 위해 **ARP Request를 Broadcast**한다.
    - ARP Request는 IP주소에 매칭되는 MAC 주소는 어디인가요?라는 요청이라 보면 된다.
2. Broadcast여서 ARP Request는 같은 LAN에 위치한 모든 노드들이 받게 되고, 타겟 노드인 PC2는 ARP Response를 보내게 된다.
    - PC2가 아닌 노드들은 무시를 한다,
3. PC0은 PC2가 보낸 ARP Response를 받고 ARP Table에 PC2의 IP와 MAC 주소를 적는다.
4. PC2에 데이터를 보내야하는 요청이 들어오면 ARP Table에 기재된 MAC 주소를 이용해 데이터를 보낸다.

> ARP Request를 처음 보낼 때는 목적지의 MAC 주소를 보내서 브로드캐스트를 하지만 ARP Response를 보낼 때는 송신자의 MAC 주소를 알아서 유니캐스트로 보내게 된다.


### Reference
- [ARP 쉽게 이해하기](https://aws-hyoh.tistory.com/entry/ARP-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

<hr>
</details>


<details>
<summary>GARP와 RARP에 대해 설명해주세요</summary>

<hr>

### GARP

- Gratuitous ARP의 약자이다.
- ARP가 상대방의 MAC 주소를 알아내기 위해 사용되었는데 **GARP는 자신의 IP와 MAC 주소를 알릴 목적으로 사용된다.**
- GARP는 로컬 네트워크에 자신의 IP와 MAC 주소를 알릴 목적으로 사용되므로 GARP의 목적지 MAC 주소는 브로드캐스트 MAC 주소를 사용한다.
    - GARP는 대상자 IP 필드에 자신의 IP 주소를 채워서 ARP요청을 보낸다.
- GARP를 사용해 동일 네트워크에 자신의 IP 주소와 MAC 주소를 알리는 이유는 아래와 같다.
    - IP 주소 충돌 감지
        - 여러 이유로 할당받은 IP가 다른 사람들이 사용하고 있을 수 있다. 통신을 할 때 IP 통신이 안 되는 것을 예방하기 위해 GARP를 통해 IP 중복을 체크한다. → GARP의 응답이 오면 중복 IP가 존재하는 것이다.
    - 상대방(동일 서브넷에 있는)의 ARP 테이블 갱신
        - 액티브-스탠바이로 동작하는 Master-Slave DB의 경우, 기존에 WAS는 DB의 MAC주소로 Master DB의 주소를 갖고 있다. 하지만 Master DB가 죽어버리면 Slave DB가 Master DB의 IP 주소를 갖고 Master로 승격하게 되는데 이때, MAC 주소는 변경되게 되는거라 변경된 DB의 MAC 주소를 알려주기 위해 GARP를 통해 테이블 갱신을 해준다.
        - 최근에는 GARP를 이용해 패킷을 가로채는 기법이 많이 사용되어 보안상의 이유나 다른 운영상의 이유로 GARP를 받더라도 ARP 테이블을 갱신하지 않는 단말들이 존재할 가능성이 있어 이런 문제가 발생하지 않는 가상 MAC을 사용하는 HA 솔루션이 사용된다.
    - HA(고가용성) 용도의 클러스터링, VRRP, HSRP
        - 가상 MAC을 사용하는 클러스터링, VRRP, HSRP와 같은 FHRP에서도 GARP가 사용된다.

### RARP

- Reverse ARP의 줄임발이다.
- **IP 주소가 정해져 있지 않은 단말이 IP를 할당해주는 서버에 IP 할당을 요청할 때 사용한다.**
- 과거에 네트워크 호스트의 주소 할당에 사용되었지만 제한된 기능으로 인해 BOOTP와 DHCP로 대체되어 사용되고 있지 않다.

<hr>
</details>

<details>
<summary>DNS에 대해 설명해주세요</summary>

<hr>

웹사이트는 외우기 어려운 IP주소 대신 naver.com과 같은 도메인 네임을 사용한다. 도메인 이름을 사용했을 때 입력한 도메인을 실제 네트워크상에서 사용하는 IP 주소로 바꾸고 해당 IP 주소로 접속하는 과정이 필요하다.이러한 과정, 전체 시스템을 **DNS(Domain Name System)** 라고 한다.

DNS는 Root DNS Server, TLD(Top-Level Domain), Authoritative DNS Server로 계층구조를 이루고 있다.

- **Root DNS Server**: ICAANN이 직접 관리하는 서버로, TLD DNS 서버들의 IP 주소를 보관하고 안내하는 역할을 한다.
- **TLD(Top-Level Domain)**: 도메인 등록기관(Registry)이 관리하는 서버로 Authoritive DNS 서버의 주소를 갖고 안내하는 역할을 한다. 각각의 TLD 서버들은 `.com`, `.kr`, `.net`등에 매칭되는 주소들을 갖고 있다.
    - 예를 들어보면 naver.com으로 요청이 들어왔다면 Root DNS에서 `.com`의 Authoritive DNS서버 주소를 가진 TLD 서버로 넘어온 후, TLD에서는 naver.com에 해당하는 Authoritive DNS 서버 주소를 반환한다.
- **Authoritive DNS Server**: 실제 도메인과 IP 주소의 정보를 갖고 있는 서버이다. 일반적으로 가비아와 같은 호스팅 업체의 **네임서버**가 해당한다.
- **Recursive DNS Server**: 인터넷 사용자가 가장 먼저 접근하는 DNS서버로, `<도메인, IP>`의 쌍을 저장하는 캐시 서버이다. SK/KT/LG와 같은 ISP(통신사) DNS 서버 등이 있다.

### **DNS 동작 과정 전체 예시**

![Untitled](img/network/dns.png)

### Reference
- [DNS란 뭐고, 네임서버란 뭔지 개념정리 | 살살살림](https://gentlysallim.com/dns란-뭐고-네임서버란-뭔지-개념정리/)
- [DNS란? (도메인 네임 시스템 개념부터 작동 방식까지) - 하나몬](https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/)

<hr>
</details>


<details>
<summary>DHCP에 대해 설명해주세요</summary>

<hr>

- DHCP는 ‘Dynamic Host Configuration Protocol(동적 호스트 구성 프로토콜)’의 약자로, 호스트의 IP 주소 및 각종 TCP/IP 프로토콜의 기본 설정을 네트워크에 연결된 장치(클라이언트)에 자동으로 제공해주는 프로토콜을이다. 즉, **네트워크 관리자가 수동으로 할당해야할 IP를 자동으로 일정 기간동안 할당(임대)해주는 역할을 한다.**
- DHCP는 IP주소를 DHCP 서버가 중앙집중식으로 관리하는 클라이언트/서버 모델을 사용한다.
- DHCP 지원 클라이언트는 네트워크 부팅 과정에서 DHCP서버에 IP 주소를 요청하면 주소를 얻을 수 있다.

> 대부분의 가정용 네트워크에서는 라우터가 DHCP서버의 역할을 한다.
>

장점

- **신뢰성 높은 DHCP IP 주소 구성**: DHCP는 동일한 IP 주소를 이용하는 두 명의 사용자 사이의 충돌을 방지하도록 도와준다. 이러한 충돌이 발생하는 경우 두 명의 사용자 모두 인터넷에 연결하지 못하게 된다. DHCP는 자동으로 이러한 충돌을 방지할 수 있다는 장점이 있다.
- **높은 이동성**: DHCP는 높은 이동성을 보장하며 사용자는 네트워크 범위 내에서 어디서든지 모바일 장치를 이용할 수 있다.
- **효율적인 네트워크 관리**: DHCP를 사용하면 별도의 IP 할당 서버가 필요하지 않아 네트워크 관리 효율성이 개선된다.
- **IP 체계의 유연성**: DHCP를 이용하면 최종 사용자에게 지장을 주지 않으면서 IP 주소 체계를 손쉽게 변경할 수 있다.

단점

- DHCP는 아무런 인증 과정을 거치지 않기 때문에 사이버 공격에 취약하다.
- DHCP 서버에 의존되는 네트워크가 만들어지게 된다.
    - DHCP서버가 죽으면 IP할당이 제대로 이루어지지 않는다.

### Reference
- [DHCP의 정의와 DHCP를 이용해야 하는 이유](https://nordvpn.com/ko/blog/what-is-dhcp/)
- [DHCP란?](https://jwprogramming.tistory.com/35)

<hr>
</details>

## ETC

<details>
<summary>LAN, MAN, WAN의 차이에 대해 설명해주세요.</summary>

<hr>

네트워크는 규모와 관리 범위에 따라 LAN, MAN, WAN으로 구분된다.

- LAN(Local Area Network): 사용자 내부 네트워크
- MAN(Metro Area Network): 한 도시 정도를 연결하고 관리하는 네트워크
- WAN(Wide Area Network): 멀리 떨어진 LAN을 연결해주는 네트워크

> 과거에는 각각 사용하는 기술들이 달라 프로토콜이나 전송 기술에 따라 쉽게 구분할 수 있었다. 하지만 최근에는 대부분의 기술이 이더넷으로 통합되며 사용자가 전송 기술을 구분하는게 무의미해져 관리 범위 기준으로 구분한다.
>

### LAN

- 홈 네트워크, 사무실 네트워크와 같이 비교적 소규모의 네트워크를 말한다.
- 먼 거리를 통신할 필요가 없어 스위치와 같이 비교적 간단한 장비로 연결되어 있다.
- 관리 범위에서의 LAN은 자신이 소유한 건물이나 대지에 직접 구축한 선로로 동작시키는 네트워크로 정의할 수 있다.

> 복잡하거나 대규모인 네트워크라도 직접 구축한 네트워크 범위라면 LAN이라고 부른다.
>

### MAN

- 수~수십 km 범위의 한 도시를 네트워크로 연결하는 개념이다.
- LAN이 모여서 MAN이 만들어진다.

### WAN

- 멀리 떨어진 네트워크를 연결하기 위해 사용한다.
- 멀리 떨어진 LAN을 서로 연결하거나 인터넷에 접속하기 위한 네트워크가 해당된다.
- 특별한 경우가 아니면 직접 구축할 수 없는 범위의 네트워크라 대부분 KT, LG, SKB와 같은 통신사 업자로부터 회선을 임대해 사용한다.

<hr>
</details>

<details>
<summary>NIC(Network Interface Card)란 무엇일까요?</summary>

<hr>

- 랜 카드, 네트워크 인터페이스 카드, 네트워크 인터페이스 컨트롤러, 네트워크 카드 등 여러 이름으로 불린다.
- 네트워크 인터페이스 카드는 컴퓨터를 네트워크에 연결하기 위한 하드웨어 장치이다.
- 고성능, 다기능으로 점점 더 진화하고 있다. 단순히 **높은 대역폭을 제공**할 뿐만 아니라 높은 대역폭 처리로 인해 CPU에 부하가 걸리지 않도록 **패킷 생성과 전송을 CPU 도움 없이 독자적으로 처리**한다.
- 일부 NIC에서는 L3스위치 기능이 내장되어 있어 가상화 서버들끼리 연결하는 vSwitch를 가속화하는 기능도 함께 제공한다.
- NIC의 역할
    - 직렬화
        - **전기적 신호**와 **데이터 신호**의 형태를 상호 변환해준다.
        - 네트워크 카드 외부 케이블에서는 전기 신호형태로 데이터가 전송되는데 이러한 상호 변환 작업을 직렬화라고 한다.
    - MAC 주소
        - NIC는 **MAC 주소를 갖고 있다.**
        - 받은 패킷의 도착지 주소가 자신의 MAC 주소가 아니면 폐기하고 자신의 주소가 맞으면 시스템 내부에서 처리하도록 전달한다.
    - 흐름 제어 (Flow Control)
        - 데이터 처리 속도로 인한 데이터 유실 방지를 위해 데이터를 받지 못할 때 상대방에게 통신 중지를 요청한다.

<hr>
</details>

<details>
<summary>유니캐스트, 멀티캐스트, 브로드캐스트, 애니캐스트에 대해 설명해주세요.</summary>

<hr>

### **유니캐스트(Unicast)**

- 1:1 통신
- 출발지와 목적지가 1:1로 통신
- 대부분의 통신은 유니캐스트 방식을 사용한다.

### **브로드캐스트(Broadcast)**

- 1:모든 통신
- 동일 네트워크에 전재하는 모든 호스트가 목적지
- 주로 유니캐스트로 통신하기 전, 상대방의 정확한 위치를 알기 위해 사용된다.

### **멀티캐스트(Multicast)**

- 1:그룹(멀티캐스트 구독 호스트) 통신
- 하나의 출발지에서 다수의 특정 목적지로 데이터 전송
- IPTV와 같은 실시간 방송을 볼 때, 멀티캐스트 통신 방식을 사용한다.

### **애니캐스트(Anycast)**

- 1:1 통신 (목적지는 동일 그룹 내의 1개 호스트)
- 다수의 동일 그룹 중 가장 가까운 호스트에서 응답
    - 주소가 같은 호스트들 중에서 가장 가깝거나 가장 효율적으로 서비스할 수 있는 호스트와 통신하는 방식이다.
- 애니캐스트 게이트웨이 성질을 이용해서 **가장 가까운 DNS 서버를 찾을 때 사용**하거나 가장 가까운 게이트웨이를 찾는 애니캐스트 게이트웨이 기능에 사용하기도 한다.
- IPv4에서는 일부 기능 구현, IPv6은 모두 구현 가능

### 정리

| 타입 | 통신 대상 | 범위 | IPv4 | IPv6 | 예제 |
| --- | --- | --- | --- | --- | --- |
| 유니캐스트 | 1:1 | 전체 네트워크 | O | O | HTTP |
| 브로드캐스트 | 1:모든 | 서브넷 (로컬 네트워크) | O | X | ARP |
| 멀티캐스트 | 1:그룹 | 정의된 구간 | O | O | 방송 |
| 애니캐스트 | 1:1 | 전체 네트워크 | △ | O | 6 to 4 DNS |

<hr>
</details>

<details>
<summary>Cookie, Session, JWT의 차이점에 대해 설명해주세요</summary>

<hr>

Http는 무상태성, 비연결성이라 연결의 정보를 저장하고 있지 않는다. 우리가 웹 서비스를 이용하며 이전의 상태를 이용할 수 있는 것은 Cookie와 Session덕분이다.

### Cookie

- 클라이언트가 웹사이트를 방문할 경우, 사이트가 사용하고 있는 서버를 통해 클라이언트의 브라우저에 설치되는 작은 기록 정보 파일이다.
- Response Header의 `Set-Cookie`필드를 이용한다.
- 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 Request Header의 `Cookie`필드에 담아 보낸다.

**단점**

- 보안에 취약합니다.
    - 요청 시 쿠키의 값을 그대로 보냅니다.
    - **유출 및 조작 당할 위험이 존재합니다.**
- 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없습니다.
- 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저간 공유가 불가능합니다.
- 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해집니다.

### Cookie & Session

- 비밀번호 등 클라이언트의 인증 정보를 쿠키가 아닌 서버 측에 저장하고 관리하는 방법이다.
    - 서버는 클라이언트의 로그인 요청에 대한 응답을 작성할 때, 인증 정보는 서버에 저장하고 클라이언트 식별자인 `JSESSIONID`를 쿠키에 담습니다.
    - 이후 클라이언트는 요청을 보낼 때마다, `JSESSIONID` 쿠키를 함께 보냅니다.
    - 서버는 `JSESSIONID` 유효성을 판별해 클라이언트를 식별합니다.

**장점**

- 쿠키를 포함한 요청이 외부에 노출되더라도 세션 ID 자체는 유의미한 개인정보를 담고 있지 않습니다.
- 각 사용자마다 고유한 세션 ID가 발급되기 때문에, 요청이 들어올 때마다 회원정보를 확인할 필요가 없습니다.

**단점**

- 해커가 `JSESSIONID` 중간에 탈취하여 클라이언트인척 위장할 수 있다는 한계가 존재합니다.
- 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해집니다.

### JWT

- JWT(JSON Web Token)란 인증에 필요한 정보들을 암호화시킨 토큰을 의미한다.
- JWT 기반 인증은 쿠키/세션 방식과 유사하게 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별합니다.
- ****Header****(해싱 알고리즘, 토큰 타입)****, Payload****(토큰에 담을 정보)****, Signature****(인코딩된 Header와 Payload를 더한 뒤 비밀키로 해싱하여 생성)
    - Header와 Payload는 단순히 인코딩된 값이기 때문에 제 3자가 복호화 및 조작할 수 있지만, Signature는 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없습니다. 따라서 Signature는 토큰의 위변조 여부를 확인하는데 사용됩니다.

**장점**

1. Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있습니다.
2. 인증 정보에 대한 별도의 저장소가 필요없습니다.
3. JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있습니다.
4. 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 무상태가 됩니다.
5. 확장성이 우수합니다.
6. 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능합니다.
7. OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있습니다.
8. 모바일 어플리케이션 환경에서도 잘 동작합니다.

**단점**

1. 쿠키/세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해집니다.
2. Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없습니다.
3. 토큰을 탈취당하면 대처하기 어렵습니다.
4. 토큰은 한 번 발급되면 유효기간이 만료될 때 까지 계속 사용이 가능하기 때문입니다.
5. 특정 사용자의 접속을 강제로 만료하기 어렵지만, 쿠키/세션 기반 인증은 서버 쪽에서 쉽게 세션을 삭제할 수 있습니다.

### Reference
- [인증 방식 : Cookie & Session vs JWT](https://tecoble.techcourse.co.kr/post/2021-05-22-cookie-session-jwt/)

<hr>
</details>

<details>
<summary>이더넷(Ethernet)이란?</summary>

<hr>

- 이더넷은 **하나의 인터넷 회선에** 유/무선 통신장비, 공유기, 허브 등을 통해 **다수의 시스템이 랜선 및 통신포트에 연결되어 통신이 가능한 네트워크 구조**를 말한다.

  > Internet과 다른점
  >
  > - Internet은 여러 네트워크를 전세계적으로 연결한 컴퓨터를 의미하지만 이더넷은 Internet내에서 네트워크를 구성하는 방식 중 한 방법이다.
- 이더넷은 OSI 7계층 중 1계층인 물리계층과 2계층인 데이터 링크 계층에서 구성 형식이 정의된다.
- 하나의 이더넷 회선에서 여러 시스템이 동시에 통신할 때 발생하는 충돌을 막기 위해 **CSMA/CD(Carrier Sence Multiple Access/ Collision Detection)** 방식으로 제어를 한다.

### Reference
- [[NW] 🌐 이더넷 이란 무엇인가? 🔌](https://inpa.tistory.com/entry/WEB-🌐-이더넷-이란-무엇인가)

<hr>
</details>

<details>
<summary>RPC란?</summary>

<hr>

- RPC(Remote Procedure Call)이란 원격에 위치한 프로그램을 로컬에 있는 프로그램처럼 사용하는 프로토콜이며 분산 서버 환경에서 노드간 통신을 쉽게 하기 위해 나온 방식이다.
- RPC는 아래의 이미지와 같이 Client와 Server 중간에서 Client가 Server에 메서드 호출을 할 경우, 호출과 결과를 전달해주는 역할을 한다.

  ![Untitled](img/network/rpc.png)

    - Caller(Client) / Callee(Server)
        - Client, Server가 필요한 비즈니스 로직을 실행하는 Layer로 IDL(Interface definition Language)로 작성된다.

          > IDL이란 인터페이스 정의 언어로 XML, JSON, Proto와 같이 정보를 저장하는 규칙이다.
    >
    - Stub
        - **메소드 스텁(method stub)**은 다른 프로그래밍 기능을 대리하는 코드이다. 즉, 실제 코드를 흉내내거나 아직 개발되지 않은 코드를 임시로 대치하는 역할을 수행한다.
        - RPC에서는 Stub Compiler가 IDL 파일을 읽어 원하는 언어로 Stub을 생성한다.
    - RPC runtime
        - Server와 Client를 Building하는 Layer
        - 커뮤니케이션 중 발생한 에러처리도 진행한다.

<hr>
</details>

<details>
<summary>gRPC란?</summary>

<hr>

- Google에서 개발한 RPC(Remote Procedure Call)시스템이다.
- TCP/IP 프로토콜과 HTTP 2.0 프로토콜 사용한다.
- IDL로 protocol buffer를 사용한다.

  > ptoro란?
  >
  > - gRPC에서 사용하는 데이터 형식으로 `.proto`파일을 protocol buffer compiler(protoc)를 이용해 컴파일하며 다양한 언어에서 다양한 데이터 스트림을 통해 데이터를 쉽게 읽고 쓸 수 있다.
  > - JSON과 비교하였을 때, 데이터의 크기가 작아 통신이 빠르고 파싱할 필요도 없다는 장점이 있다.
- RPC의 특성대로 클라이언트의 어플리케이션은 다른 머신에 있는 서버 애플리케이션의 메서드가 마치 로컬 객체인 것처럼 호출할 수 있다.
    - 덕분에 분산 서비스를 쉽게 만들 수 있다.
    - 언어와 상관없이 다른 환경에서 실행이 가능하다.

  ![Untitled](img/network/grpc.png)

- 장점
    - 성능과 문제 개선
        - protocol buffer를 통해 리소스 사용량을 크게 줄여 JSON을 사용할 때보다 네크워크 사용량과 응답 속도를 줄일 수 있다.
    - 서버-클라이언트 Streaming
        - HTTP 2.0의 multiduplex bidirectional streaming 기능 제공한다.
    - 다양한 언어에서 사용이 가능하다.
        - C#, C+, Dart, Go, Java, Kotline, Node, Object-C, PHP, Python, Ruby 지원 (proto3)
- 단점
    - 브라우저에서의 사용이 곤란하다.
        - 브라우저(Client)에서 proto 파일을 가지고 있을 수 없으므로 사실상 사용 불가능
    - 서버의 proto 파일에 변화가 있을 경우, 클라이언트의 proto 파일도 업데이트해줘야 한다.

### Reference
- [gRPC란?](https://hirlawldo.tistory.com/119)

<hr>
</details>

<details>
<summary>NAT(Network Address Translation)이란?</summary>

<hr>

- 인터넷에 접속하지 않거나 NAT(Network Address Translation)을 사용할 경우(공유기나 회사 방화벽을 사용하는 경우) 사설 IP를 사용할 수 있다.
- 사설 IP를 사용하면 인터넷에 직접 접속하지 못하지만 IP를 변환해주는 NAT 장비에서 공인 IP로 변경한 후에 인터넷 접속이 가능하다.
    - 가정의 공유기가 대표적인 NAT이다.

<hr>
</details>

<details>
<summary>공인 IP와 사설 IP란 무엇일까요?</summary>

<hr>

- 전 세계에서 사용하는 식별자인 IP를 공인 IP라고 한다. 하지만 인터넷 연결 없이 개인적으로 네트워크를 구성하면 공인 IP를 사용하지 않고도 네트워크를 구축할 수 있다.
- 인터넷에 접속하지 않거나 NAT(Network Address Translation)을 사용할 경우(공유기나 회사 방화벽을 사용하는 경우) 사설 IP를 사용할 수 있다.
- 사설 IP는 인터넷 표준 문서인 RFC에 명시되어 있다.
- 사설 IP를 사용하면 인터넷에 직접 접속하지 못하지만 IP를 변환해주는 NAT 장비에서 공인 IP로 변경한 후에 인터넷 접속이 가능하다.
    - 가정의 공유기가 대표적인 NAT이다.

> 사설 IP는 다른 사용자(외부)에 할당된 (공인)IP를 사용하면 안된다. 그래서 인터넷 어느 구간에서도 사용되지 않는 RFC에 명시된 사설 IP를 사용하는 것을 추천한다.

- 사설 IP는 A 클래스 1개, B 클래스 16개, C 클래스 256개를 사용할 수 있다.

<hr>
</details>
